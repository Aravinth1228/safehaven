import { useState, useEffect, useCallback, useRef } from 'react';
import { contractService } from '@/lib/contract/contractService';
import { TouristStatus } from '@/lib/contract/abi';
import { Tourist, DangerZone, EmergencyAlert, fromContractCoordinate, fromContractTimestamp } from '@/lib/contract/types';
import { useToast } from '@/hooks/use-toast';

interface EmergencyAlertEvent {
  tourist: string;
  touristId: string;
  lat: number;
  lng: number;
  timestamp: Date;
}

interface StatusUpdateEvent {
  tourist: string;
  status: number;
  timestamp: Date;
}

interface DangerZoneEvent {
  zoneId: number;
  name: string;
  lat: number;
  lng: number;
  radius: number;
}

export function useContract() {
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  
  // Event callbacks
  const emergencyCallbackRef = useRef<((event: EmergencyAlertEvent) => void) | null>(null);
  const statusCallbackRef = useRef<((event: StatusUpdateEvent) => void) | null>(null);
  const dangerZoneCallbackRef = useRef<((event: DangerZoneEvent) => void) | null>(null);

  const initialize = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      await contractService.initialize();
      setIsInitialized(true);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to initialize contract';
      setError(message);
      toast({
        title: 'Contract Error',
        description: message,
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // Auto-initialize when MetaMask is available
  useEffect(() => {
    if (window.ethereum && !isInitialized) {
      initialize();
    }
  }, [initialize, isInitialized]);

  // Setup event listeners when initialized
  useEffect(() => {
    if (!isInitialized) return;

    // Emergency Alert listener
    contractService.onEmergencyAlertCreated((alertId, tourist, touristId, status, timestamp) => {
      // Note: Your contract doesn't emit lat/lng in EmergencyAlertCreated event
      const event: EmergencyAlertEvent = {
        tourist,
        touristId,
        lat: 0, // Not available in event
        lng: 0, // Not available in event
        timestamp: fromContractTimestamp(timestamp),
      };
      emergencyCallbackRef.current?.(event);
    });

    // Status Update listener
    contractService.onStatusUpdated((tourist, touristId, oldStatus, newStatus, timestamp) => {
      const event: StatusUpdateEvent = {
        tourist,
        status: Number(newStatus),
        timestamp: fromContractTimestamp(timestamp),
      };
      statusCallbackRef.current?.(event);
    });

    // Danger Zone Created listener
    contractService.onDangerZoneCreated((zoneId, name, lat, lng, radius, level, createdBy) => {
      const event: DangerZoneEvent = {
        zoneId: 0, // Index not available in event
        name,
        lat: fromContractCoordinate(lat),
        lng: fromContractCoordinate(lng),
        radius: Number(radius),
      };
      dangerZoneCallbackRef.current?.(event);
    });

    return () => {
      contractService.removeAllListeners();
    };
  }, [isInitialized]);

  const onEmergencyAlert = useCallback((callback: (event: EmergencyAlertEvent) => void) => {
    emergencyCallbackRef.current = callback;
  }, []);

  const onStatusUpdate = useCallback((callback: (event: StatusUpdateEvent) => void) => {
    statusCallbackRef.current = callback;
  }, []);

  const onDangerZoneAdded = useCallback((callback: (event: DangerZoneEvent) => void) => {
    dangerZoneCallbackRef.current = callback;
  }, []);

  const getRegistrationFee = useCallback(async () => {
    // Your contract doesn't charge fees
    return '0';
  }, []);

  const getOwner = useCallback(async () => {
    try {
      return await contractService.getOwner();
    } catch {
      return null;
    }
  }, []);

  /**
   * Register tourist on blockchain
   * Returns the tourist ID generated by the contract
   */
  const registerTourist = useCallback(
    async (touristId: string, username: string, email: string, phone: string, dob: Date) => {
      try {
        setIsLoading(true);
        
        toast({ 
          title: 'Blockchain Registration', 
          description: 'Please confirm transaction in MetaMask...' 
        });
        
        const tx = await contractService.registerTourist(touristId, username, email, phone, dob);
        
        toast({ 
          title: 'Transaction Sent', 
          description: 'Registering on blockchain...' 
        });
        
        const receipt = await tx.wait();
        
        // Get the tourist ID from the blockchain
        const signerAddress = await contractService.getSignerAddress();
        const blockchainTouristId = await contractService.getTouristIdFromBlockchain(signerAddress);
        
        toast({ 
          title: 'Success', 
          description: 'Registered on blockchain!' 
        });
        
        return blockchainTouristId || touristId; // Fallback to generated ID if fetch fails
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Registration failed';
        toast({ title: 'Error', description: message, variant: 'destructive' });
        throw err;
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  const updateStatus = useCallback(
    async (status: 'Safe' | 'Alert' | 'Emergency') => {
      try {
        setIsLoading(true);
        const tx = await contractService.updateStatus(status);
        toast({ title: 'Transaction Sent', description: 'Updating status...' });
        await tx.wait();
        toast({ title: 'Success', description: `Status updated to ${status}` });
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Status update failed';
        toast({ title: 'Error', description: message, variant: 'destructive' });
        return false;
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  const updateLocation = useCallback(
    async (lat: number, lng: number) => {
      try {
        const tx = await contractService.updateLocation(lat, lng);
        await tx.wait();
        return true;
      } catch (err) {
        console.error('Location update failed:', err);
        return false;
      }
    },
    []
  );

  const getTourist = useCallback(async (address: string) => {
    try {
      return await contractService.getTourist(address);
    } catch {
      return null;
    }
  }, []);

  const isAdmin = useCallback(async (address: string) => {
    try {
      return await contractService.isAdmin(address);
    } catch {
      return false;
    }
  }, []);

  const addDangerZone = useCallback(
    async (name: string, lat: number, lng: number, radius: number, level: string) => {
      try {
        setIsLoading(true);
        const tx = await contractService.createDangerZone(name, lat, lng, radius, level);
        toast({ title: 'Transaction Sent', description: 'Adding danger zone...' });
        await tx.wait();
        toast({ title: 'Success', description: 'Danger zone added to blockchain!' });
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to add danger zone';
        toast({ title: 'Error', description: message, variant: 'destructive' });
        return false;
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  const removeDangerZone = useCallback(
    async (zoneId: number) => {
      try {
        setIsLoading(true);
        const tx = await contractService.removeDangerZone(zoneId);
        toast({ title: 'Transaction Sent', description: 'Removing danger zone...' });
        await tx.wait();
        toast({ title: 'Success', description: 'Danger zone removed!' });
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to remove danger zone';
        toast({ title: 'Error', description: message, variant: 'destructive' });
        return false;
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  const getAllDangerZones = useCallback(async () => {
    try {
      return await contractService.getAllActiveDangerZones();
    } catch {
      return [];
    }
  }, []);

  const dismissAlert = useCallback(
    async (alertId: number) => {
      try {
        setIsLoading(true);
        const tx = await contractService.dismissAlert(alertId);
        toast({ title: 'Transaction Sent', description: 'Dismissing alert...' });
        await tx.wait();
        toast({ title: 'Success', description: 'Alert dismissed!' });
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to dismiss alert';
        toast({ title: 'Error', description: message, variant: 'destructive' });
        return false;
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  const getActiveEmergencyAlerts = useCallback(async () => {
    try {
      return await contractService.getActiveEmergencyAlerts();
    } catch {
      return [];
    }
  }, []);

  return {
    isInitialized,
    isLoading,
    error,
    initialize,
    getRegistrationFee,
    getOwner,
    registerTourist,
    updateStatus,
    updateLocation,
    getTourist,
    isAdmin,
    addDangerZone,
    removeDangerZone,
    getAllDangerZones,
    dismissAlert,
    getActiveEmergencyAlerts,
    // Event listeners
    onEmergencyAlert,
    onStatusUpdate,
    onDangerZoneAdded,
    getSignerAddress: () => contractService.getSignerAddress(),
    getContractAddress: () => contractService.getContractAddress(),
    getTouristCount: () => contractService.getTouristCount(),
  };
}